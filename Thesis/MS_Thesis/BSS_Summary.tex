\chapter{مرور مفاهیم پایه}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section[مرو مفاهیم پایه]{\lr{DevOps} چیست؟}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{تعریف}
دِواپس که از اتحاد واژگان 
\lr{Development}
 و
\lr{Operation}
به وجود آمده است؛ ترکیبی از ابزارها، کنش‌ها و فرهنگ کاری است که تیم های توسعه\footnote{\lr{Development}} و عملیات\footnote{\lr{Operation}} را به همکاری موثرتر نزدیک می کند و کسب و کارها با استفاده از می‌توانند اپلیکیشن‌ها و سرویس‌هایشان را با سرعت بالاتری نسبت به روش‌های سنتی تحویل دهند. همین سریع‌تر شدن سرعت توسعه و انتشار نرم‌افزار، سازمان‌ها را قادر می‌سازد تا در مقایسه با کسب‌وکارهایی که هنوز از روش‌های سنتی توسعه نرم‌افزار استفاده می‌کنند خدمات بهتری به مشتریانشان ارائه دهند. در واقع دواپس سعی دارد تا مشکل جدایی تیم‌های مختلف را رفع کرده و یک فرهنگ سازمانی یکپارچه را میان تیم‌های مختلفی که در حال توسعه یک نرم‌افزار هستند ایجاد کند. از این جهت بسیاری از کارها می‌تواند به صورت خودکار پیش رفته و در نهایت همه چیز با سرعت بیشتری صورت بگیرد \cite{DevopsDef1,DevopsDef2}. این خودکار سازی با استفاده از خط لوله
\lr{CI/CD}
از منبع کد شروع می شود و تا مانیتورینگ محصول ادامه میابد \cite{DevopsCICD1}.

تا قبل از تشکیل دواپس، تیم‌های توسعه نرم‌افزار یا تیم عملیاتی در محیط‌های جداگانه کار می‌کردند. هدف تیم توسعه تولید محصول جدید و یا افزودن ویژگی‌های جدیدی روی محصولات قبلی بود. هدف تیم عملیاتی نیز ثابت نگه داشتن وضعیت موجود سرویس‌ها برای پایداری بیشتر بود. به مرور زمان در فرآیند توسعه نرم‌افزار، روش‌های چابک\footnote{\lr{Agile}}
ایجاد شد تا با مشتری تعامل بهتری برقرار شود و نیازهایی که دارد به محصول اضافه شود \cite{DevopsAgile}. جدایی دو تیم توسعه و عملیات از هم باعث می‌شد که در فرآیند تولید محصول و استقرار\footnote{\lr{Deploy}} آن، اتلاف وقت ایجاد شود و محصول دیرتر به دست مشتری برسد \cite{DevopsCD}.

\subsection{چرخه کاری \lr{DevOps}}
همانطور که در شکل 
~\ref{fig: Phases of DevOps}
مشاهده می کنید،
\lr{DevOps}
قصد دارد از ابزار و جریان های کاری\footnote{\lr{Workflow}} برای خودکارسازی یک یا چند مورد از موارد زیر استفاده کند: 
\begin{enumerate}
	\item
کدنویسی: شامل توسعه، بازبینی کد و ابزارهای کنترل نسخه است. مثلا، یک تیم تصمیم می گیرد از گیت\footnote{\lr{Git}} به عنوان ابزار کنترل نسخه و از گیت هاب\footnote{\lr{Github}} نیز به عنوان یک مخزن راه دور استفاده کند. این تیم مجموعه‌ای از دستورالعمل‌های سبک کدنویسی را با استفاده از ابزاری نظیر \lr{Linter} به همراه حداقل درصد پوشش تست تعریف کرده و با تعیین استراتژی انشعاب مبتنی بر تنه\footnote{\lr{Trunk-Based}} تغییرات خود را به منظور بازبینی برای ادغام با انشعاب اصلی\footnote{\lr{Merge request}} برای توسعه دهنده ارشد ارسال می کند \cite{Devopstrunk}.
	\item 
ساخت: شامل ایجاد و ذخیره خودکار مولفه\footnote{\lr{Artifact}} ها می باشد. به طور مثال یک تیم تصمیم می گیرد یک \lr{Container image} قابل اجرا از محصول خود ایجاد کند.
	\item 
تست: شامل ابزارهایی برای تست محصول می باشد. تیم محیطی را به منظور تست هر تغییر جدید راه اندازی می کند که در آن مجموعه‌ای از آزمایش‌ها مانند آزمون واحد\footnote{\lr{Unit test}}، آزمون یکپارچگی\footnote{\lr{Integration test}} و ... به‌طور خودکار در برابر هر ویرایش کد اجرا می‌شود.
	\item 
انتشار: این مرحله شامل استراتژی انتشار است. به طور مثال تیم می تواند تصمیم بگیرد که یک محصول به طور مستقیم منتشر شود یا ابتدا در یک محیط آزمایشی مورد ارزیابی قرار گیرد. هم چنین در مواقعی که مشکلی در استقرار وجود دارد چه کاری انجام دهند و استراتژی بازگشت\footnote{\lr{Rollback}} خود را پیاده سازی کنند.
	\item 
پیکربندی: شامل پیکربندی و مدیریت خودکار زیرساخت می باشد. این مورد شامل مجموعه ای از اسکریپت هایی برای بازتولید محیط در حال اجرا و زیرساخت نرم افزاری شامل سیستم عامل تا پایگاه داده و سرویس های خاص و پیکربندی شبکه آنها می باشد \cite{DevopsIaac1, DevopsIaac2}.
	\item 
نظارت: از عملکرد محصول تا نظارت بر تجربه کاربر نهایی را شامل می شود. به عنوان مثال، می‌تواند مدت زمان درخواست‌های پایگاه داده یا بارگذاری وب‌سایت یا تعداد کاربرانی که از ویژگی‌های خاص محصول استفاده می‌کنند یا تعداد بازدیدکنندگان از یک وب‌سایت که به ثبت نام ختم می‌شود یا تعداد کاربران جدید در یک مجموعه زمانی خاص را پوشش دهد. مرحله نظارت هم چنین شامل هشدار خودکار خرابی ها نیز می باشد (به عنوان مثال، آستانه استفاده از \lr{CPU}) \cite{DevopsMonitor}. درنهایت نظارت بر محیط تولید به منظور اطمینان از صحت کارکرد صحیح محصول ضروری است.

\end{enumerate}
\begin{figure}[tb]
	\centering
	\unitlength 1.2cm 
	\begin{LTR}
		\begin{picture}(11,2) % width and height of the picture
			\thicklines
			% Nodes
			\put(0,1){\circle{1}} \put(0,1){\makebox(0,0){Code}}
			\put(2,1){\circle{1}} \put(2,1){\makebox(0,0){Build}}
			\put(4,1){\circle{1}} \put(4,1){\makebox(0,0){Test}}
			\put(6,1){\circle{1}} \put(6,1){\makebox(0,0){Release}}
			\put(8,1){\circle{1}} \put(8,1){\makebox(0,0){Configure}}
			\put(10,1){\circle{1}} \put(10,1){\makebox(0,0){Monitor}}
			
			% Arrows
			\put(0.5,1){\vector(1,0){1}}
			\put(2.5,1){\vector(1,0){1}}
			\put(4.5,1){\vector(1,0){1}}
			\put(6.5,1){\vector(1,0){1}}
			\put(8.5,1){\vector(1,0){1}}
			
			% Rectangle around the "Configure" node with label
			\put(1,0){\framebox(10,2){}} % Drawing the rectangle
			\put(5.5,0.1){\makebox(0,0)[bl]{Automated}} % Adding label "Automated"
		\end{picture}
	\end{LTR}     
	\label{fig: Phases of DevOps}
	%\farsi 
	\caption{مراحل \lr{DevOps}}
\end{figure}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{تاریخه \lr{BSS}}
با توجه به ظاهر  \lr{ill posed} مسألهٔ \lr{BSS}، مطرح شدن آن در پردازش سیگنال نسبتاً
دیرهنگام بوده است. امکان حل مسألهٔ \lr{BSS} نخستین بار در سال  ۱۹۸۵ و توسط
هِرو (\lr{H\'erault})، ژوتن (\lr{Jutten}) و اَنس (\lr{Ans}) در یک کاربرد بیولوژیکی ارائه شد 
\cite{HeraJA85} (اولین مقاله بین‌المللی روی این موضوع به زبان انگلیسی
\cite{HeraJ86} است). ایده اولیه حدود سال ۱۹۸۲ و هنگامی بوجود آمد
که این تیم روی یک مساله بیولوژیکی کار می‌کرد و مشاهده کردند که هنگام
انتقال اطلاعاتِ مربوط به سرعت و مکان زاویه‌ایِ یک مفصل به مغز، اطلاعات
مربوط به سرعت و مکان توسط دو سیگنال عصبی مختلف به مغز ارسال
می‌شوند، ولی در هر دوی این سیگنالها اطلاعات مکان و سرعت با هم مخلوط
هستند و در نتیجه مغز حتماً باید روشی برای جداکردن این اطلاعات داشته باشد.
به عبارتی مغز باید به طریقی بتواند سیستم معکوس را تنها از روی مشاهدات
تخمین بزند. آنها در نهایت روشی برای تخمین پارامترهای سیستم معکوس یافتند
که بعدها به آلگوریتم \lr{HJ} (\lr{H\'erault-Jutten}) معروف شد.

    \begin{figure}[tb]
     \centering
     \unitlength 0.5cm \linethickness{0.4pt}
     \begin{LTR}
     \begin{picture}(8.25,4)(-1,0)
       \put(0,0){\vector(1,0){2}}
       \put(0,3){\vector(1,0){2}}

       \put(-1,-0.5){\makebox(1,1)[cc]{$x_2$}}
       \put(-1,2.5){\makebox(1,1)[cc]{$x_1$}}

       \put(2.25,0){\circle{0.5}}
       \put(2.25,3){\circle{0.5}}
       \put(2.1,0){\line(1,0){0.3}}
       \put(2.1,3){\line(1,0){0.3}}
       \put(2.25,-0.15){\line(0,1){0.3}}
       \put(2.25,2.85){\line(0,1){0.3}}

       \put(3.2,2.3){\makebox(1,1)[cb]{{\small $-m_{12}$}}}
       \put(3.2,0.3){\makebox(1,1)[cb]{{\small $-m_{21}$}}}


       \put(2.5,0){\vector(1,0){4}}
       \put(2.5,3){\vector(1,0){4}}
       \put(6.5,-0.5){\makebox(1,1)[cc]{$y_2$}}
       \put(6.5,2.5){\makebox(1,1)[cc]{$y_1$}}

       \put(5.25,0){\vector(-1,1){2}}
       \put(5.25,3){\vector(-1,-1){2}}

       \put(5.25,0){\line(-1,1){2.82}}
       \put(5.25,3){\line(-1,-1){2.82}}

       \put(5.25,0){\circle*{0.3}}
       \put(5.25,3){\circle*{0.3}}
     \end{picture}
     \end{LTR}     

\label{fig: HJ Sep Sys}
%\farsi 
\caption{سیستم جداساز در روش \lr{HJ}}
    \end{figure}
هِرو و  ژوتن برای جداسازی دو سیگنال مخلوط‍، ابتدا مدل فیدبک‌دار شکل~\ref{fig: HJ Sep Sys}
را برای سیستم جداساز در نظر گرفتند.
روشن است که این مدل با انتخاب مناسب ضرایب  $m_{12}$ و $m_{21}$ قادر است 
سیگنالها را از هم جدا کند. در واقع داریم:
\begin{equation}
    \left\{\begin{array}{rcc}
        y_1 &\eqnarrayeq& x_1 - m_{12} y_2 \\
        y_2 &\eqnarrayeq& x_2 - m_{21} y_1
      \end{array}
    \right.
\end{equation}
و یا به فرم ماتریسی  $\yb=\xb-\Mb\yb$، که در آن:
\begin{equation}
\Mb \triangleq \left[\begin{array}{cc} 1 & m_{12} \\
m_{21} & 2
\end{array}
\right]
\end{equation}
در نتیجه خواهیم داشت:
\begin{equation}
\yb = (\Ib + \Mb)^{-1} \xb
\end{equation}
بنابراین اگر ضرایب $m_{12}$ و $m_{21}$ بگونه‌ای انتخاب شوند که $\Ib+\Mb=\Ab$ 
شود (که در آن  $A\triangleq[a_{ij}]$ ماتریس ضرایب مخلوط‌کننده است)، 
منابع از هم جدا خواهند شد. البته این معادلات تنها نشان می‌دهند که سیستم 
شکل~\ref{fig: HJ Sep Sys} قادر به جداسازی منابع است و هیچ راه عملیی برای تعیین
پارامترهای سیستم جداساز بدست نمی‌دهد، چراکه ماتریس مخلوط  $\Ab$
مجهول است. سپس آلگوریتم \lr{HJ} (به عنوان اولین آلگوریتم جداسازی منابع و اولین
آلگوریتمی که قابل حل بودن مساله \lr{BSS} را نشان داد) بر مبنای این ایده استوار 
است که با توجه به اینکه منابع از هم مستقل آماری هستند، ضرایب  
$m_{12}$ و $m_{21}$ باید بگونه‌ای تعیین شوند که خروجی‌های $y_1$ و $y_2$ 
هم مستقل آماری باشند. از طرف دیگر دو تابع غیرخطی و فرد $f$ و $g$ را در 
نظر بگیرید .اگر $E\{f(y_1)g(y_2)\}$ و $E\{f(y_2)g(y_1)\}$  برابر صفر شوند
(میانگین سیگنالها صفر فرض شده است)، از روی بسط تیلور این توابع می‌توان انتظار
داشت که کلیه ممانهای متقابل (از مرتبه فرد $y_1$ و $y_2$) صفر باشند که به 
معنی استقلال آماری آنهاست. در نهایت  هِرو و ژوتن آلگوریتم زیر را برای تعیین ضرایب 
$m_{12}$ و  $m_{21}$ پیشنهاد کردند:
\begin{equation}
    \left\{
      \begin{array}{rcc}
        m_{12} \leftarrow m_{12} - \mu f(y_1) g(y_2) \\
        m_{21} \leftarrow m_{21} - \mu f(y_2) g(y_1)
      \end{array}
    \right.
\end{equation}
که در آن  عدد مثبت کوچکی است که  \lr{learning rate} را تعیین می‌کند. سپس  هِرو و 
ژوتن توابع فرد ساده‌ای مثل $f(y)=y^3$ و $g(y)=\arctan(y)$ را در نظر گرفتند 
و نشان دادند که این آلگوریتم واقعاً قادر است سیگنالهای مخلوط را جدا کند، به عبارتی حل 
مسألهٔ \lr{BSS} ممکن است. 

زیبایی و سادگی آلگوریتم \lr{HJ} در حل یک مسألهٔ ظاهراً پیچیده به تدریج توجه
محققان دیگر را نیز به این مسأله جلب کرد. برخی از آنها (مثل  \lr{Lacoume}) در
ابتدا تنها برای آنکه اشتباه بودن ادعای  \lr{HJ} را نشان دهند به کار روی این مسأله
پرداختند، که این تلاشها در نهایت منجر به اثبات ریاضی قابل حل بودن \lr{BSS}، و
ارائه آلگوریتم‌های بهتری برای آن شد \cite{Card89b,LacoR88,Como89c}.
با این وجود تا میانه دهه ۱۹۹۰، این مسأله بیشتر در بین محققان فرانسوی باقی
ماند و معدود مقالات بین‌المللی ارائه شده در کنفرانسهای شبکه‌های عصبی، در
بین انبوه مقالات روی موضوعاتی چون \lr{back-propagation}، شبکه‌های هاپفیلد و
\lr{Kohonen's self organizing maps} که در آن موقع مورد توجه زیاد محققان
شبکه‌های عصبی بودند، مدفون شد.

زمینه متفاوت دیگری که در آن موقع در حال گسترش بود،  
\lr{Higher Order Spectral Analysis} (\lr{HOS}) بود که نخستین کنفرانس آن در سال  
۱۹۸۹ برگزار شد و کارهای \lr{Cardoso} و  \lr{Comon} در این کنفرانس ارائه شدند
\cite{Card89b,Como89c}.

از حدود میانه دهه ۱۹۹۰ و بعد از آنکه \lr{Bell} و \lr{Sejnowski} روش خود را بر مبنای
\lr{Infomax} ارائه کردند \cite{BellS95}، این مسأله مورد توجه بیشتر
محققان قرار گرفت و آلگوریتم‌های مختلفی برای حل مسأله در حالتهای مختلف
ارائه گردید. بخصوص باید به روش \cite{CardL96} اشاره کرد که خانواده‌ای از 
روشهای \lr{equivariant} برای جداسازی منابع معرفی می‌کند. در این روشها، 
کیفیت جداسازی به  \lr{condition number} ماتریس مخلوط‌کننده بستگی
ندارد، یعنی هرچه هم که سیگنالها به شدت مخلوط شده باشند (خروجی
سنسورها به هم شبیه باشند، یا دترمینان ماتریس مخلوط‌کننده به صفر نزدیک باشد)، 
تأثیری در کیفیت نهایی جواب ندارند (در عدم حضور نویز).

از حدود میانه دهه ۹۰ مقالات در این زمینه به سرعت افزایش یافت. اولین
کنفرانس بین‌المللی روی این موضوع (\lr{ICA99}) در سال ۹۹  در فرانسه برگزار شد 
که در آن بیش از یکصد محقق که روی این مساله کار می‌کردند، 
گرد هم آمدند. این کنفرانس از آن سال تا کنون هر $1.5$ سال یکبار و
در کشورهای مختلف برگزار می‌شود (\lr{ICA2009} قرار است در برزیل برگزار شود).

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{کاربردهای \lr{BSS}}
با آنکه مساله \lr{ICA} یا \lr{BSS} نسبتاً مبحث جدیدی در پردازش سیگنال است، تا
کنون استفاده از آن در کاربردهای مختلفی گزارش شده است. از جمله این
کاربردها می‌توان موارد زیر را برشمرد:
\begin{itemize}
\item کاربرد در  \lr{Feature extraction} در پردازش تصویر.

\item جداسازی تصاویر مخلوط.

\item کاربرد در \lr{Denosing} سیگنال تصویر.

\item استفاده در جداسازی سیگنالهای پزشکی \lr{EEG}،  \lr{ECG} و \lr{MEG}.

\item استفاده در حذف سروصدای ماشین از صدای ضبط شده در گوشی تلفن همراه.

\item استفاده در حذف نویز و سروصدا به عنوان یک بلوک پیش~پردازش در
سیستمهای تشخیص صحبت (\lr{Speech recognition}). با استفاده از چنین بلوکی می‌توان 
نرخ تشخیص صحبت را افزایش داد.

\item حل  \lr{cocktail party problem} (جداسازی چند سیگنال صحبت مخلوط). این
کاربرد یکی از مشکلترین کاربردهای  \lr{BSS} است که با آنکه برای مخلوطهای
مصنوعی و سیگنالهایی که در یک اتاق آکوستیک ضبط شده‌اند، بخوبی کار
می‌کند، برای جداسازی مخلوط ضبط~شده در یک اتاق معمولی (وقتی از
روی دیوارها اکو وجود دارد) هنوز کیفیت روشهای ارائه‌شده چندان بالا
نیست.

\item استفاده در تشخیص همزمان چند جسم در سیستم‌های تشخیص شیء 
با استفاده از القای الکترومغناطیسی. در این سیستم‌ها هر شخص یا
شیء یک  \lr{Label} دارد که حضور آن در نزدیکی سنسور مربوطه باعث
شناسایی شخص یا شیء می‌شود. با استفاده از  \lr{ICA} امکان
\lr{identification} همزمان چند  \lr{label} بوجود می‌آید (وقتی چند  \lr{label} در
نزدیکی دستگاه تشخیص ظاهر می‌شوند). این کاربرد  \lr{patent} شده است.

\item استفاده در مخابرات (\lr{CDMA}).

\item کاربرد در اقتصاد (استخراج عوامل پنهان در اطلاعات تجاری).

\item کاربرد در شناسایی جو: یک سیگنال به طرف جو فرستاده می‌شود،
انعکاسهای آن از روی لایه‌های مختلف جو با استفاده از  \lr{ICA} از هم جدا
می‌شوند که هرکدام در برگیرنده اطلاعاتی در مورد لایه‌های مختلف جو
است.

\item کاربرد در زمین‌شناسی: مشابه روش قبل برای شناسایی لایه‌های مختلف زمین.

\item کاربرد در ستاره‌شناسی: مؤلفه‌های مستقل تصاویر دریافتی از فضا با استفاده 
از  \lr{ICA} استخراج می‌شوند و از روی آنها اطلاعاتی در مورد منابع
مستقلی که آنها را ارسال کرده‌اند بدست می‌آید.
\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{\lr{ICA} به عنوان روشی برای حل مسأله \lr{BSS}}
دیدیم که ایده اصلی حل مسأله \lr{BSS}
استفاده از  استقلال منابع و بیرون کشیدن مؤلفه‌های مستقلِ
مشاهدات است. به همین دلیل، گرفتن یک بردار مشاهده و تجزیه آن به مؤلفه‌های مستقل را
«\underline{تجزیه به مولفه‌های مستقل}» 
یا\lr{ICA} (\lr{Independent Component Analysis}) نام‌گذاری کردند. به عبارت دیگر،
\lr{ICA} به هر آلگوریتم یا روشی اطلاق می‌شود که نمونه‌هایی از یک بردار تصادفی را به عنوان ورودی  
دریافت کرده، و در خروجی مؤلفه‌های مستقل آن را بدست می‌دهد، یعنی مؤلفه‌هایی می‌دهد که از یکدیگر
بطور آماری  مستقل هستند و بردار ورودی را می‌توان به صورت ترکیب این مؤلفه‌های مستقل بیان کرد.

این نام‌گذاری در مقایسه با تبدیل قدیمی‌تر «تجزیه به مؤلفه‌های اصلی 
(\lr{PCA}\footnote{\lr{Principal Component Analysis}})» انجام گرفته است: \lr{PCA} نمونه‌های یک بردار تصادفی را
دریافت کرده و تحت یک تبدیل ماتریسی دوران، خروجیهایی بدست می‌دهد که با یکدیگر ناهمبسته (\lr{decorrelated})
هستند و ورودیها را می‌توان به صورت ترکیب خطی این مؤلفه‌های ناهمبسته بیان کرد.

بنابراین تفاوت \lr{PCA} و \lr{ICA} آن است که \lr{PCA} به تبدیلی از نوع دوران محدود است ولی \lr{ICA} نیست. در عوض،
\lr{PCA} خروجیهایی می‌دهد که از یکدیگر ناهمبسته هستند (اسقلال درجه ۲)، ولی لزوماً مستقل آماری نیستند، اما
\lr{ICA} خروجیهایی می‌دهد که به مفهوم دقیق مستقل (و نه فقط ناهمبسته) هستند. 
به عنوان مثال به سادگی می‌توان نشان داد که 
در \lr{BSS} بدست آوردن خروجی‌هایی که از هم ناهمبسته باشند برای بازیابی منابع کافی نیست و ناهمبستگی (به عنوان
تقریبی از استقلال) نمی‌تواند مسأله \lr{BSS} را حل کند، و برای حل این مسأله استقلال کامل نیاز است. به عبارتی
نمی‌توان \lr{PCA} را برای حل مسأله \lr{BSS} به کار برد.

البته توجه داریم که \lr{ICA} دو ابهام ذاتی نیز دارد: تغییر ترتیب مؤلفهای مستقل و نیز تغییر انرژی آنها
تغییری در استقلال آنها نمی‌دهد. مثلاً در \lr{BSS} که تنها اطلاعات ما از منابع استقلال آماری آنها است، 
منابع را می‌توان از روی مخلوطها به دست آورد ولی با ابهام در انرژی و ترتیب آنها؛ به عبارت دیگر،
انرژی و ترتیب منابع را نمی‌توان تنها از روی فرض استقلال آماری آنها به دست آورد. البته 
بازیابی منابع با این دو ابهام
در بسیاری از کاربردها قابل قبول است  و اهمیت چندانی ندارد.

در حالتیکه تعداد سنسورها مساوی با تعداد منابع باشد، \lr{ICA} متداول‌ترین روش برای \lr{BSS} است. البته تعمیم 
\lr{ICA} به حالتی که تعداد سنسورها از منابع بیشتر باشد نیز بسیار ساده است.
برای مطالعه بیشتر در مورد \lr{ICA} خواننده را به 
مقالات مروری~\cite{MansBO00,LeeGBS99,HyvaO00,Hyva99Survey,Card98}، 
کتابهای~\cite{CichA02,HyvaKO01} و مراجع ذکر~شده در آنها ارجاع می‌دهیم.


